/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package simpledb

import simpledb.jdbc.embedded.EmbeddedDriver
import simpledb.jdbc.network.NetworkDriver
import java.sql.Driver
import java.sql.SQLException
import java.sql.Statement
import java.sql.Types
import java.util.Scanner

@Suppress("NestedBlockDepth", "PrintStackTrace")
class SimpleIJ {
    val greeting: String
        get() {
            return "Hello World!"
        }

    fun start() {
        val sc = Scanner(System.`in`)
        println("Connect> ")
        val s = sc.nextLine()
        val d: Driver = if (s.contains("//")) NetworkDriver() else EmbeddedDriver()
        try {
            d.connect("dbdir/$s", null).use { conn ->
                conn.createStatement().use { stmt ->
                    print("\nSQL> ")
                    while (sc.hasNextLine()) {
                        // process one line of input
                        val cmd = sc.nextLine().trim { it <= ' ' }
                        if (cmd.startsWith("exit")) {
                            break
                        } else if (cmd.startsWith("select")) {
                            doQuery(
                                stmt,
                                cmd
                            )
                        } else {
                            doUpdate(
                                stmt,
                                cmd
                            )
                        }
                        print("\nSQL> ")
                    }
                }
            }
        } catch (e: SQLException) {
            e.printStackTrace()
        }
        sc.close()
    }

    private fun doQuery(stmt: Statement, cmd: String) {
        try {
            stmt.executeQuery(cmd).use { rs ->
                val md = rs.metaData
                val numcols = md.columnCount
                var totalwidth = 0

                // print header
                for (i in 1..numcols) {
                    val fldname = md.getColumnName(i)
                    val width = md.getColumnDisplaySize(i)
                    totalwidth += width
                    val fmt = "%" + width + "s"
                    System.out.format(fmt, fldname)
                }
                println()
                for (i in 0 until totalwidth) print("-")
                println()

                // print records
                while (rs.next()) {
                    for (i in 1..numcols) {
                        val fldname = md.getColumnName(i)
                        val fldtype = md.getColumnType(i)
                        val fmt = "%" + md.getColumnDisplaySize(i)
                        if (fldtype == Types.INTEGER) {
                            val ival = rs.getInt(fldname)
                            System.out.format(fmt + "d", ival)
                        } else {
                            val sval = rs.getString(fldname)
                            System.out.format(fmt + "s", sval)
                        }
                    }
                    println()
                }
            }
        } catch (e: SQLException) {
            println("SQL Exception: " + e.message)
        }
    }

    private fun doUpdate(stmt: Statement, cmd: String) {
        try {
            val howmany = stmt.executeUpdate(cmd)
            println("$howmany records processed")
        } catch (e: SQLException) {
            println("SQL Exception: " + e.message)
        }
    }
}

fun main() {
    SimpleIJ().start()
}
